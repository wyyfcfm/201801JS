预解释（变量提升）：一个阶段，在当前作用域下，代码执行之前，对带var和function关键字的进行声明和定义
声明：在内存里一个开辟一个空间保存变量 var num; var
定义：不仅有这个变量还给他赋值 var num = 10;  function

函数运行的步骤：
1.开辟一个私有的作用域 （闭包）
2.形参赋值
3.预解释
4.代码从上往下执行

作用域：
1.全局作用域：浏览器加载页面时形成  全局变量 var num = 10;num = 10;
2.私有作用域：函数运行时形成  私有变量：形参和带var关键字
    若在函数内定义的变量没有带var:
    1.先判断下是否是私有的，若是则就是他不用往上找了
    2.若不是，则往上级作用域找，若没找到则继续往上级作用域找，...一直window,若没找到则报错 ->作用域链
    上级作用域:函数在哪定义则上级作用域就是谁,跟函数在哪执行无关

无节操之预解释
1.只对等号左边的进行预解释
2.return 后面不预解释，但是下面还是要预解释
3.重名变量不会重复声明，但是可以重复定义
4.自执行函数function本身不会预解释
5.带var ,不管条件是否成立都预解释 function ,标准浏览器下只会声明，ie下会声明+定义

内存释放
作用域释放问题：
通常情况下，函数运行完就销毁
作用域不销毁：
1.不立即销毁：函数运行完以后，返回一个需要被执行的小函数，只有等小函数执行完后，函数才销毁
2.不销毁：函数内部的内容被外界给占用，这时不销毁

堆内存释放
 堆内存引用地址被其他变量占用，这时堆内存释放不了，只有当变量设为null,也就是变成空指针，在浏览器空闲时，利用垃圾回收机制，会释放这块内容

this  函数运行时调用的主体
1.函数运行时，方法名前面是否有.,若有.则方法名前面是谁，this就是谁
2.自执行函数里的this为window
3.事件驱动函数运行时，函数里的this是当前绑定的元素

面向对象（oop）:object oriented programming 以对象数据类型为导向的编程
对象 类 实例
对象：万物皆对象     地球                        统称
类：对象中细分的类型  动物类，植物类，微生物类....  范围抽象
实例：实实在在的事物  一个人，一棵数，一朵花....    具体事物

object
内置类 Number/String/Boolean/Null/Undefined/
对象类里细分类 Array/RegExp/Math/Date/
对象中独立出来特殊的类型 Function
元素类  oUl->HTMLUListElement->HTMLElement->Element->Node->EventTarget->Object
Object类是基类，其他的属于派生类

对象定义：
var obj = {name:"lily",age:18};字面量的方式
var obj = new Object();

var ary = [1,2,3,4]
var ary = new Array(10);数组的长度为10
var ary = new Array("10");数组中只有一项，这一项为字符串10
var ary = new Array(10,20,30);多个参数时，括号里的参数就是数组里的成员
->es6 解决es5传参的问题，传啥数组里的成员就是啥
var ary = Array.of(40);

好处：
1.对所有的数据分类，这样便于操作与识别
2.对不同的数据，可以在其相应的类上添加一些操作
3.更加了解数据在浏览器里的内在机制

面向对象的设计模式
单例模式  工厂模式  构造函数模式  原型模式
根据实际项目的需求一步一步演变过来的

起初项目实现模块化开发，一个项目是由多人合作的，每个人负责一个模块
->单例模式 一种最简单的模块化开发的方式
本质：实际上就是一个对象
优点：1.防止代码的冲突和污染
     2.具有封装性
模块之间的调用：
     1)不同模块之间：模块名.属性名
     2)同模块之间：this.属性名
 这种单例模式叫门户大开型
 若有些变量或方法想设成私有的，不想其他模块调用，如何解决呢?
 ->高级单利模式 有私有，有暴露在外，功能全，满足需求
缺点：手工业操作的方式,效率低，有很多冗余代码

工厂模式
1)提供原材料                1)新建一个对象
2)原材料加工和生产           2)对对象添加属性和方法
3)输出产品                  3)返回对象

缺点：加工出来的全是对象,没法识别 产品的差异化问题没法解决

构造函数(类)模式：
与工厂模式的区别：
1.工厂模式的1),3)不需要，只需要第二步
2.工厂模式：函数名()  构造函数模式：new 函数名()
注意事项：
1.函数名首字符大写
2.this.xxx 方式添加属性,构找函数里的this指实例
3.new 函数名运行，若不需要传参，小括号可不写，需要传参函数名后加括号
4.new运行的函数称为构造函数
5.以实例为上下文运行构造函数，运行完后会自动返回这个实例
6.this.xxx这个属性是实例的属性,var a = 10;只是函数内部的私有属性和实例无关
7.若手动增加返回值，
    若返回的是引用类型的数据则会覆盖默认返回的实例
    若返回的是基本类型的数据则不会覆盖
8.this.xxx这些属性都是实例私有的，各个实例之间互不相干

优点：实现产品的差异化，实现分类
缺点：所有的属性都是私有的,没法实现公有化
例如：有些功能是属于这个类的实例所公有的功能，不需要在每个实例上都实现一遍，只需要每个实例调用下公有的这个功能即可

原型模式
 解决产品公有化问题
 原型的基础知识(强制记住)：
 1.所有的函数（构造函数）里有一个属性叫prototype,prototype是一个原型对象
 2.所有的对象都有一个属性叫__proto__,它指向所属类的原型
 3.prototype上天生存在一个属性叫constructor,它指向于(构造)函数

 属性查找的顺序：
 先去实例上找，若找到则用自身实例上的,若没找到，则通过__proto__去所属类的原型上查找，若还没找到，继续通过__proto__去所属类的原型上查找...，直到找到Object.prototype,若没找到，则返回undefined ->这样的过程就形成原型链
 __proto__是实现在所属类的原型上查找的关键属性，是实现继承的关键














